{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>TrenchBoot is a framework that allows individuals and projects to build security engines to perform launch integrity actions for their systems. The framework builds upon Boot Integrity Technologies (BITs) that establish one or more Roots of Trust (RoT) from which a degree of confidence that integrity actions were not subverted.</p>"},{"location":"#where-to-start","title":"Where to Start","text":"<ul> <li>General Architecture - A top level overview of TrenchBoot</li> <li>Use Case Definition - A collection of example use cases</li> <li>Developers Guide - A developers guide that explains the internals of TrenchBoot</li> </ul>"},{"location":"#contributors","title":"Contributors","text":""},{"location":"FAQ/","title":"TrenchBoot FAQ","text":"<ol> <li>Why does TrenchBoot use an intermediate launcher?</li> <li>What are the benefits of measurement over signature validation?</li> <li>What do I need to incorporate TrenchBoot into my system?</li> <li>Where do I start if I want to help with contributions?</li> </ol>"},{"location":"FAQ/#1-why-does-trenchboot-use-an-intermediate-launcher","title":"1. Why does TrenchBoot use an intermediate launcher?","text":"<p>For Linux systems doing both verified(secure) and measured boot, there is an intermediary that handles the security enforcement. For verified boot it is the UEFI shim loader and for measured boot it is tboot. TrenchBoot replaces these intermediary loaders with a common Linux-based loader that provides a rich security processing framework. One role that TrenchBoot does not fulfill is that the UEFI shim also serves as a trust delegation point that transitions from Microsoft Authority to Distribution/Installer/No Authority. The response why this is not of concern will be addressed in Question 2.</p>"},{"location":"FAQ/#2-what-are-the-benefits-of-measurement-over-signature-validation","title":"2. What are the benefits of measurement over signature validation?","text":"<p>It is important to understand that one solution is not necessarily more beneficial over the other. Measurement and Verification each have their merits and it is important to understand the environment and requirements of the solution. In the case of verification, it provides a one-time strong assertion to origination and correctness that relies on Authorities and Control which becomes brittle when dealing with delegating control. For example when verification is being used as the Root of Trust that the transitive trust builds upon, these solutions are strongest when the ecosystem is closed and under control of a core entity. Where as measurement provides for establishing a strong assertion to correctness that can be repeatedly extended and verified. It therefore relies on the ability to know what correct is and to securely verify measurement with expected correctness.</p>"},{"location":"FAQ/#3-what-do-i-need-to-incorporate-trenchboot-into-my-system","title":"3. What do I need to incorporate TrenchBoot into my system?","text":"<p>TrenchBoot is a framework that allows you to build a Linux kernel with a tailored, embedded initramfs that functions as an intermediate loader to launch your system. You will need to use the build system to select the security engine components you desire, provide any necessary configurations, and build an instance of the loader. After that, you configure your system boot to launch the loader.</p>"},{"location":"FAQ/#4-where-do-i-start-if-i-want-to-help-with-contributions","title":"4. Where do I start if I want to help with contributions?","text":"<p>The TrenchBoot Blueprints are how feature requests are collected for the project. Check if there is a blueprint that is of interested, if not, submit a blueprint via a pull request for a feature you would like to see implemented.</p>"},{"location":"code/","title":"Code Repositories","text":"<p>Core project repositories for TrenchBoot project.</p> <ul> <li>GRUB SecureLaunch for Intel<ul> <li>Latest snapshot of Intel TXT support for GRUB</li> </ul> </li> <li>GRUB SecureLaunch for AMD<ul> <li>Latest snapshot of AMD SKINIT support for GRUB</li> </ul> </li> <li>Linux 5.13 SecureLaunch for Intel and AMD<ul> <li>Latest snapshot Linux Secure Launch for Intel &amp; AMD</li> </ul> </li> <li>Secure Kernel Loader<ul> <li>Implementation of the AMD Secure Loader specification for SKINIT</li> </ul> </li> <li>Tools for Linux SecureLaunch<ul> <li>A suite of tools for development, debugging, and launch status.</li> </ul> </li> </ul>"},{"location":"community/","title":"Community","text":"<p>How to get in contact with the team.</p> <ul> <li>TrenchBoot Google Group</li> <li>Twitter</li> <li>#trenchboot channel on OSFW Slack</li> </ul>"},{"location":"events/","title":"Conferences","text":"<p>Events that TrenchBoot appeared on.</p>"},{"location":"events/#worldwide-conferences","title":"Worldwide conferences","text":"<ul> <li>Open Source Firmware Conference 2020<ul> <li>Video: TrenchBoot DRTM features for AMD platforms</li> <li>Slides</li> </ul> </li> <li>UEFI Plugfest 2020<ul> <li>Video: TrenchBoot and GRUB - A Quick Introduction</li> <li>Slides</li> </ul> </li> <li>Xen Project Developer and Design Summit 2020<ul> <li>Video: Xen system boot attestation with DRTM and TPM2</li> <li>Slides</li> </ul> </li> <li>Platform Security Summit 2019<ul> <li>Video: Less-Insecure Network Edge Virtualization with Low Size, Weight and Power</li> <li>Slides</li> </ul> </li> <li>Xen Project Developer and Design Summit 2019<ul> <li>Video: How TrenchBoot is Enabling Measured Launch for Open-Source Platform Security</li> <li>Slides</li> </ul> </li> <li>Linux Plumbers Conference 2019<ul> <li>Video: TrenchBoot - How to Nicely Boot System with Intel TXT and AMD SVM</li> <li>Slides</li> </ul> </li> <li>Linux Security Summit 2019<ul> <li>Video: TrenchBoot - How to Nicely Boot System with Intel TXT and AMD SVM</li> <li>Slides</li> </ul> </li> <li>Open Source Firmware Conference 2019<ul> <li>Video: TrenchBoot - Open DRTM implementation for AMD platforms</li> <li>Slides</li> </ul> </li> <li>Grub2 and 3mdeb \"minisummit\" 2019<ul> <li>Video: AMD TrenchBoot support in GRUB2</li> <li>Slides</li> </ul> </li> <li>Platform Security Summit 2018<ul> <li>Video: TrenchBoot and System Boot Integrity</li> <li>Slides</li> </ul> </li> </ul>"},{"location":"events/#trenchboot-events","title":"TrenchBoot events","text":"<ul> <li>Linux Secure Launch - TrenchBoot Summit 2021</li> <li>TrenchBoot Developers Forum 2021</li> </ul>"},{"location":"upcoming_events/","title":"Upcoming Events","text":""},{"location":"blueprints/","title":"Blueprints","text":"<p>Here you will find the design artifacts for built, in progress, and planned security engine components.</p> <p>{nav}</p>"},{"location":"blueprints/AMD_Grub_Late_Launch/","title":"AMD Grub Late Launcher","text":""},{"location":"blueprints/AMD_Grub_Late_Launch/#purpose","title":"Purpose","text":"<p>The intent of this project is to extend Grub with the ability to call the AMD SKINIT instruction.</p>"},{"location":"blueprints/AMD_Grub_Late_Launch/#background","title":"Background","text":"<p>The AMD SKINIT instruction is a means to initiate a \"late launch\" that establishes a Dynamic Root of Trust Measurement (DRTM). The instruction call requires the system to be in a specific state as enumerated below,  * SVM check, either the <code>EFER.SVME</code> bit is set to 1 or the feature flag <code>CPUID    Fn8000_0001_ECX[SKINIT]</code> is set to 1  * The CPU must be in protected mode  * All microcode needs to be unloaded</p>"},{"location":"blueprints/AMD_Grub_Late_Launch/#approach","title":"Approach","text":"<p>Grub will be extended with the following capabilities,  * An SKINIT relocator that will,   1. set protected mode   2. enable APIC   3. verify no machine check in progress   4. clear machine check regs   5. SKINIT as final instruction  * A late launch loader that will,   1. load kernel starting at 0x100000, compatibility with a Linux Secure Loader   2. verify SVM is supported   3. disable all TPM localities   4. evict microcode   5. send INIT IPI to all APs</p>"},{"location":"blueprints/AMD_Landing_Zone/","title":"AMD Landing Zone","text":""},{"location":"blueprints/AMD_Landing_Zone/#purpose","title":"Purpose","text":"<p>The intent of this project is to implement the earliest code that is launched by a DL Event on AMD platforms.</p>"},{"location":"blueprints/AMD_Landing_Zone/#background","title":"Background","text":"<p>Contrary to the TXT solution, SKINIT is a single CPU instruction after which the execution is passed to the user-provided block of code, called Secure Loader in AMD documents. To some extent, this code can be treated as the AMD equivalent of ACM, except that it doesn't have to be signed by the CPU vendor.</p> <p>SKINIT extends PCR17 with the hash of SL, which size is specified in the SL header (maximum of 64K - 1), protects SLB (Secure Launch Block, always 64K) against DMA access from the devices, puts the CPU in defined execution state and jumps to the entry point also specified in the header. At the entry point to the SL the CPU works in flat 32-bit protected mode with paging disabled. Most general purpose registers are cleared. Interrupts are disabled (held pending until re-enabled), including NMI, SMI and INIT. Refer to AMD APM Vol 2 for more details.</p> <p>Landing Zone is an implementation of Secure Loader.</p>"},{"location":"blueprints/AMD_Landing_Zone/#approach","title":"Approach","text":"<p>This is a high-level overview of tasks performed by Landing Zone: 1. set GDT and segment registers (only CS and SS are valid after SKINIT) 2. enable Long Mode (optional) 3. initialize TPM interface 4. initialize TPM event log    * log what was done by SKINIT 5. extend PCR18 with the hash of data passed by the bootloader to the LZ    * log that event 6. obtain information about the kernel from the data provided by a bootloader,    most notably:    * kernel location    * kernel size    * entry point 7. extend PCR17 with the hash of the kernel    * log that event 8. set CPU registers according to the kernel boot protocol 9. jump to the entry point of kernel</p>"},{"location":"blueprints/AMD_Landing_Zone/#things-that-yet-have-to-be-implemented","title":"Things that yet have to be implemented","text":""},{"location":"blueprints/AMD_Landing_Zone/#dma-protection-must-be-extended-to-cover-any-additional-code-and-data","title":"DMA protection must be extended to cover any additional code and data","text":"<p>This includes mainly kernel and zero page. As of now, it is impossible to do this securely.</p> <p>AMD APM Vol 2 states that it should be done with DEV (Device Exclusion Vector), but that is no longer implemented on new CPUs, except for initial SLB protection (starting with Family 17h, even that protection is handled differently).</p> <p>DEV was surpassed by the IOMMU. It is much more capable than DEV, but it also requires more data and code to set up. Those are not atomic operations, data must be first written to memory by the CPU, then CPU sends information to the IOMMU that it can parse that data, and only then the IOMMU actually reads that memory. A rogue device could potentially modify that data in the meantime, so it all should happen in the protected part of the memory.</p> <p>The issue is that IOMMU is also treated as a device, so it cannot access the memory protected by the DEV (or what's left of it). There are two possible options, both of which result in window of opportunity for unauthorized change of the memory: * turn off the SLB protection before sending commands to the IOMMU * build IOMMU structures outside of SLB</p> <p>The second approach requires also that the space for those structures is reserved and that LZ knows about its location.</p>"},{"location":"blueprints/AMD_Landing_Zone/#build-options","title":"Build options","text":"<p>There are 3 configurable options, specified as command line parameters for <code>make</code>. All of them are disabled by default, they can be enabled by running <code>make &lt;opt&gt;=y</code>, where <code>&lt;opt&gt;</code> is one of the flags listed below. Note that between builds with different sets of options you must run <code>make clean</code>.</p> <ul> <li>LTO - link time optimizations. Generally reduces the size of resulting   binary and execution time, but the exact difference is hard to predict.</li> <li>32 - do not jump to 64b mode. Saves 7*4 KB by not producing paging tables,   and some additional space because of shorter GDT and less strict padding.</li> <li>DEBUG - enable debug output on serial port (0x3f8). Increases the size by   about 1.3 KB.</li> </ul>"},{"location":"blueprints/Linux_Late_Launch/","title":"Linux Late Launch Kernel","text":""},{"location":"blueprints/Linux_Late_Launch/#summary","title":"Summary","text":"<p>The Linux kernel will be extended to make it function as the late launch kernel for both AMD (Secure Loader) and Intel TXT (Measured Launch Environment). </p>"},{"location":"blueprints/Linux_Late_Launch/#background","title":"Background","text":"<p>The late launch process provides a means to measure a target execution environment and then jump into the environment as presribed by the CPU's late launch protocol. This process provides a means by which to a establish a hardware-based Root of Trust for Measurement (RTM). The implementation here will provide a means to launch the Linux kernel as an RTM envrionment to enable building trust in a platform's launch.</p>"},{"location":"blueprints/Linux_Late_Launch/#approach","title":"Approach","text":"<p>A preliminary approach is as follows,  * Create a late-launch landing zone (LZ) in 64k real code section of Linux    kernel header   * Sanitize any CPU state passed through late launch   * Verify LZ signature with pubkey   * Verify measurement from LZ signature against CRTM   * (AMD) Create/Setup TPM Event log   * Extend hash of pubkey into PCR 18, record in event log    * This aligns to TXT's DA scheme   * Parse Linux header to detect relevant details about kernel   * DEV/DMAR protect remainder of Linux kernel   * Extend hash of Linux kernel into PCR 17, record in event log   * Prepare and then handoff to Linux kernel proper    * Need to support Legacy/CSM and UEFI environments  * Add a new start/launch path to Linux kernel   * Secure rendezvous APUs   * Process system state passed up from LZ     * e.g. memory map, etc.   * Setup Linux state for handover to mainline start up   * Jump into mainline start up</p>"},{"location":"blueprints/Measured_Secure_Boot/","title":"Measured Secure Boot","text":""},{"location":"blueprints/Measured_Secure_Boot/#purpose","title":"Purpose","text":"<p>To build a Measured Secure Boot (MSB) implementation that uses a hardware based Root of Trust for Measurement (RTM) from which to build a Root of Trust for Verification (RTV).</p>"},{"location":"blueprints/Measured_Secure_Boot/#background","title":"Background","text":"<p>To date the only supported Late Launch environment is the tboot project which is maintained by Intel for their Intel TXT capability. While tboot provides a complete capability, it is limited and has a number of deficiencies. While it would be possible to build a Measured Secure Boot solution around tboot, it will still be limited in comparison to approach provided by this blueprint.</p> <p>Before detailing the approach and the improvements it provides, it is good to understand how the tboot environment works. Before tboot can run, it must be loaded into memory along with the target kernel it will launch into by either a legacy multiboot compliant bootloader or by an UEFI boot manager. Tboot itself is composed of two main parts, pre-launch and post-launch execution paths. Below is a top-level execution flow for tboot from boot loader/manager to the trusted kernel that will be given control.</p> <pre><code>                        |--          tboot             --|\nboot ldr/mngr --load--&gt; pre-launch --SENTER--&gt; post-launch --launch--&gt; trusted kernel\n</code></pre> <p>In terms of integrity policy, tboot policy can only be used to measure and verify any multiboot modules loaded by the boot loader/manager. Typically tboot policy is used in one of two manners, enforcing and non-enforcing. In both cases the policy is used to control what tboot will measure and which PCRs those measurements are stored. When an enforcing policy is in place, the measurements are compared with values populated in the policy and will take a selected action when the measurements do not match. With a non-enforcing policy, measurement comparison is not done and it is left to the trusted kernel to take action on the measurements. This means if advanced actions other than measurement verification is desired, then the trusted kernel must be aware and made to take the actions.</p>"},{"location":"blueprints/Measured_Secure_Boot/#approach","title":"Approach","text":"<p>The x86 Late Launch capability will be used to establish an RTM using a Dynamic Root of Trust Measurement (DRTM) that will include the device owner's RSA public key. The Late Launch will start a TrenchBoot Security Engine (TSE) that is capable of simple measurement verification similar to tboot, but will be able to do advance actions such as a KMIP attestation for device encryption key.</p> <p>MSB will consist of an enhancement to the GNU GRUB bootloader (grub), an extended Linux kernel, and the uroot initramfs environment. The enhancement to grub will be to add TPM 1.2/2.0 support along with relocators for AMD and Intel Late Launch instructions. The Linux kernel will be extend to function as a post-launch kernel that will run the TSE. Details for each of these are documented in their own respective blueprints. Finally, below is the execution flow for MSB for comparison with tboot's execution flow above.</p> <pre><code>grub --SENTER/SKINIT--&gt; Linux/TSE --kexec--&gt; trusted kernel\n</code></pre>"},{"location":"blueprints/TXT_Grub_Late_Launch/","title":"TXT Grub Late Launcher","text":""},{"location":"blueprints/TXT_Grub_Late_Launch/#purpose","title":"Purpose","text":"<p>The intent of this project is to extend Grub with the ability to call the Intel SENTER instruction.</p>"},{"location":"blueprints/TXT_Grub_Late_Launch/#background","title":"Background","text":"<p>The Intel SENTER instruction is a means to initiate a \"late launch\" that establishes a Dynamic Root of Trust Measuremnt (DRTM). The instruction call requires the system to be in a specific state as enumerated below,</p>"},{"location":"blueprints/TXT_Grub_Late_Launch/#approach","title":"Approach","text":"<p>Grub will be extended with the following capabilities,  * An SENTER relocator that will,   1. set protected mode   2. enable cache   3. enable native FPU error reporting   4. ensure not in virtual-8086 mode   5. verify no machine check in progress   6. parse GETSEC[PARAMETERS]   7. clear machine check regs   5. senter as final instruction  * Extend the late launch loader,   1. Determine CPU type and select SKINIT or SENTER path   1. load ACM and verify it matches platform   2. verify SENTER is supported   3. build pagetable for MLE</p>"},{"location":"documentation/","title":"TrenchBoot Documentation","text":"<p>Here you will find documentation for building and using security engine components.</p> <p>{nav}</p>"},{"location":"documentation/Architecture/","title":"General Architecture","text":"<p>The general execution flow for TrenchBoot is broken into three phases, Bootstrap, Intermediate, and Runtime. The Bootstrap phase primarily consists of the existing bootstrap technology, e.g. UEFI, grub, UEFI shim, etc. For TrenchBoot the bootstrap technologies that have an integrity function, referred to as a Boot Integrity Technology (BIT), are of primary interest. The Intermediate phase is that which the TrenchBoot Loader executes to establish the launch integrity of the system. The last phase is the Runtime phase and is where the target runtime, hypervisor, operating system, etc, is given control over the system.</p> <p></p>"},{"location":"documentation/Architecture/#trenchboot-security-engine","title":"TrenchBoot Security Engine","text":"<p>At the heart of the TrenchBoot Loader is the TrenchBoot Security Engine.  The Security Engine is responsible for processing any evidence collected by the BITs, collecting new evidence as needed, evaluating all evidence according to a security policy, and executing appropriate enforcement actions. The components that enable this and their relationship can be seen in the top level diagram below.</p> <p></p>"},{"location":"documentation/Architecture/#evidence","title":"Evidence","text":"<p>A core concept in TrenchBoot is that of evidence. For TrenchBoot, evidence is a record of an event that occurred within the system. The typical form for these records is a cryptographic hash of the system state that was the result of this event. This cryptographic hash is often referred to as a measurement.</p>"},{"location":"documentation/Architecture/#boot-integrity-technology","title":"Boot Integrity Technology","text":"<p>Boot Integrity Technologies (BITs) are software or hardware capabilities that are responsible for a portion of system launch. Specifically these capabilities attempt to establish and/or enforce a degree of integrity that the correct logic was used to launch the system.</p>"},{"location":"documentation/Architecture/#bit-augmentation","title":"BIT Augmentation","text":"<p>There may be BITs that need be directly or indirectly extended to enable or enhance their usage for launching a TrenchBoot environment.</p>"},{"location":"documentation/Architecture/#bit-ingestion","title":"BIT Ingestion","text":"<p>A TrenchBoot Security Engine must be capable of supporting a variety of evidence formats for the various BITs supported. Translation of these various formats allows TrenchBoot to maintain normalized data structures for evidence collected. This allows the functionality in Security Processor to only have to reason about normalized data without specialized logic for different data formats.</p>"},{"location":"documentation/Architecture/#security-processor","title":"Security Processor","text":"<p>At the heart of a TrenchBoot Security Engine is the Security Processor. The Security Processor consist of the logical components that will consume a launch policy and take one or more actions to evaluate the state of the system necessary to enforce the policy. This may include, but is not limited to, collecting additional evidence, making attestation assertions, retrieving encryption keys, and file/block/drive decryption. The enforcement of the security policy will result in a full, partial, or failed boot of the system.</p>"},{"location":"documentation/Architecture/#launchhand-off","title":"Launch/Hand Off","text":"<p>Ultimately TrenchBoot's responsibility is to launch a target environment. As such it must be equipped with the various ways required to launch those target environments.</p>"},{"location":"documentation/CI_infrastracture/","title":"TrenchBoot CI infrastructure","text":""},{"location":"documentation/CI_infrastracture/#pipelines","title":"Pipelines","text":""},{"location":"documentation/CI_infrastracture/#upstream","title":"Upstream","text":"<ul> <li>nixos-trenchboot-configs</li> <li>landing-zone</li> <li>grub-tb</li> <li>linux-tb</li> <li>meta-trenchboot</li> </ul>"},{"location":"documentation/CI_infrastracture/#development","title":"Development","text":"<ul> <li>landing-zone</li> <li>grub-tb</li> <li>linux-tb</li> </ul>"},{"location":"documentation/CI_infrastracture/#job-descriptions","title":"Job descriptions","text":"<ul> <li>nixos-trenchboot-configs</li> <li>landing-zone</li> <li>grub-tb</li> <li>linux-tb</li> <li>meta-trenchboot</li> </ul>"},{"location":"documentation/CI_jobs/","title":"Jobs description","text":""},{"location":"documentation/CI_jobs/#landing-zone","title":"landing-zone","text":""},{"location":"documentation/CI_jobs/#build_debug_disabled","title":"build_debug_disabled","text":"<p>Job builds landing-zone with disabled debug option.</p>"},{"location":"documentation/CI_jobs/#build_debug_enabled","title":"build_debug_enabled","text":"<p>Job builds landing-zone with enabled debug option.</p>"},{"location":"documentation/CI_jobs/#build_nixpgs_debug_disabled","title":"build_nixpgs_debug_disabled","text":"<p>Job triggers building landing-zone NixOS package with disabled debug option.</p>"},{"location":"documentation/CI_jobs/#build_nixpkgs_debug_enabled","title":"build_nixpkgs_debug_enabled","text":"<p>Job triggers building landing-zone NixOS package with enabled debug option.</p>"},{"location":"documentation/CI_jobs/#grub-tb","title":"grub-tb","text":""},{"location":"documentation/CI_jobs/#build_and_install","title":"build_and_install","text":"<p>Job builds TrenchBoot version of the GRUB. Then installs the GRUB in the docker and checks if required modules are available.</p>"},{"location":"documentation/CI_jobs/#build_nixpkg","title":"build_nixpkg","text":"<p>Job triggers building the GRUB package for the NixOS.</p>"},{"location":"documentation/CI_jobs/#linux-tb","title":"linux-tb","text":""},{"location":"documentation/CI_jobs/#build","title":"build","text":"<p>Job builds linux kernel with the secure launch driver.</p>"},{"location":"documentation/CI_jobs/#build_nixpkg_1","title":"build_nixpkg","text":"<p>Job triggers building the NixOS package of the TrenchBoot linux kernel.</p>"},{"location":"documentation/CI_jobs/#nixos-trenchboot-configs","title":"nixos-trenchboot-configs","text":""},{"location":"documentation/CI_jobs/#build_lz_debug_disabled_local","title":"build_lz_debug_disabled_local","text":"<p>Job builds NixOS landing-zone package with disabled debug option.</p>"},{"location":"documentation/CI_jobs/#build_lz_debug_enabled_local","title":"build_lz_debug_enabled_local","text":"<p>Job builds NixOS landing-zone package with enabled debug option.</p>"},{"location":"documentation/CI_jobs/#build_grub","title":"build_grub","text":"<p>Job builds NixOS package of the TrenchBoot GRUB.</p>"},{"location":"documentation/CI_jobs/#build_linux","title":"build_linux","text":"<p>Job builds NixOS package of the TrenchBoot linux kernel.</p>"},{"location":"documentation/CI_jobs/#meta-trenchboot","title":"meta-trenchboot","text":""},{"location":"documentation/CI_jobs/#build_1","title":"build","text":"<p>Job builds legacy Yocto TrenchBoot for the PC Engines apu2.</p>"},{"location":"documentation/CI_jobs/#build_uefi","title":"build_uefi","text":"<p>Job builds UEFI Yocto TrenchBoot image for generic x86-64 hardware.</p>"},{"location":"documentation/CI_jobs/#test_boot_apu2","title":"test_boot_apu2","text":"<p>Job installs the legacy Yocto TrenchBoot image on the the PC Engines apu2. Then boot the platform without and with DRTM. In the end the job verifies, if PCR values correspond to manually extended.</p>"},{"location":"documentation/CI_jobs/#test_boot_asrock","title":"test_boot_asrock","text":"<p>Job installs the UEFI Yocto TrenchBoot image on the the ASRock-R1000V. Then boot the platform without and with DRTM. In the end the job verifies, if PCR values correspond to manually extended.</p>"},{"location":"documentation/CI_jobs/#test_boot_supermicro","title":"test_boot_supermicro","text":"<p>Job installs the UEFI Yocto TrenchBoot image on the Supermicro M11SDV-8CT-LN4F. Then boot the platform without and with DRTM. In the end the job verifies, if PCR values correspond to manually extended.</p>"},{"location":"documentation/CI_jobs/#test-infrastructure","title":"Test infrastructure","text":"<ul> <li>PC Engines apu2</li> <li>ASRock-R1000V</li> <li>Supermicro M11SDV-8CT-LN4F</li> </ul>"},{"location":"documentation/CONTRIBUTING/","title":"Contributing to TrenchBoot","text":"<p>We love your input! We want to make contributing to this project as easy and transparent as possible, whether it's:</p> <ul> <li>Reporting a bug</li> <li>Discussing the current state of the code</li> <li>Submitting a fix</li> <li>Proposing new features</li> <li>Becoming a maintainer</li> </ul>"},{"location":"documentation/CONTRIBUTING/#project-structure","title":"Project Structure","text":"<p>The functionality being developed under TrenchBoot are cross-cutting capabilities that span multiple open source projects.  The role of TrenchBoot is to function as both a development as well as a cross-project integration project. As such it maintains a set of repository clones of upstream project(s) that TrenchBoot conducts development within. </p>"},{"location":"documentation/CONTRIBUTING/#upstream-repository","title":"Upstream Repository","text":"<p>For each upstream repository within TrenchBoot will have at least one maintainer. The maintainer(s) will have merge permissions and responsible for maintaining adherence to upstream practices. When necessary, they are responsible for maintaining out-of-tree capabilities developed by TrenchBoot.</p>"},{"location":"documentation/CONTRIBUTING/#upstream-focus","title":"Upstream Focus","text":"<p>One of the primary objectives for TrenchBoot is to deliver interoperable launch integrity capabilities to existing open source projects involved with the system boot cycle. Under this objective, all development against an upstream project must comply with upstream coding style and strive to minimize disruption/breakage of upstream capabilities.</p>"},{"location":"documentation/CONTRIBUTING/#out-of-tree-maintenance","title":"Out of Tree Maintenance","text":"<p>There may be a case that a TrenchBoot capability may encounter a slow adoption by an upstream project which results in multiple upstream releases without the capability merged. As such the capability in question must be kept in sync with upstream changes. While this situation is not desired, it is likely to occur and will be the responsibility of the respective TrenchBoot maintainer(s).</p>"},{"location":"documentation/CONTRIBUTING/#trenchboot-original-repositories","title":"TrenchBoot Original Repositories","text":"<p>While the focus is on delivering capabilities into upstream projects, it is possible that a new or derivative code base may result to fulfill a role in a cross-cutting capability. The maintainer(s) for these code bases will be responsible for establishing coding styles and licensing that ensure compliance with all other TrenchBoot relevant projects.</p>"},{"location":"documentation/CONTRIBUTING/#development","title":"Development","text":"<p>We use github to host the project, to include tracking issues and feature requests, as well as accept pull requests.</p>"},{"location":"documentation/CONTRIBUTING/#development-flow-overview","title":"Development Flow Overview","text":"<p>Pull requests are the best way to propose changes to the project (we use Github Flow). We actively welcome your pull requests:</p> <ol> <li>Fork the repo and create your branch from <code>master</code>.</li> <li>If you've added code that should be tested, add tests.</li> <li>If you've changed APIs, update the documentation.</li> <li>Ensure the test suite passes.</li> <li>Make sure your code lints.</li> <li>Issue that pull request!</li> </ol>"},{"location":"documentation/CONTRIBUTING/#contribution-licensing","title":"Contribution Licensing","text":"<p>TrenchBoot is a cross-community integration project consisting of project repositories along with upstream project repositories. All contributions to a repository are made under the license that covers all work in that repository.</p>"},{"location":"documentation/CONTRIBUTING/#issue-tracking","title":"Issue Tracking","text":"<p>Report issues, e.g. bugs, feature requests, etc., using Github's issues</p> <p>Great Issues tend to have:</p> <ul> <li>A quick summary and/or background</li> <li>For bug reports include:</li> <li>Steps to reproduce for bugs<ul> <li>Be specific!</li> <li>Give sample code if you can.</li> </ul> </li> <li>What you expected would happen</li> <li>What actually happens</li> <li>Notes (possibly including why you think this might be happening, or stuff     you tried that didn't work)</li> <li>For feature requests include:</li> <li>An outline of how the feature would work</li> <li>Any dependecies the feature would require</li> <li>The benefit the feature will provide</li> </ul>"},{"location":"documentation/CONTRIBUTING/#coding-style","title":"Coding Style","text":"<p>Markdown documents should be formatted to 80 columns to the extent possible. Exception to the 80 column is when column limitation breaks markdown rendering.</p> <p>Contributions targeting upstream project repositories will follow the upstream project's coding style rules.</p>"},{"location":"documentation/CONTRIBUTING/#license","title":"License","text":"<p>  This work is licensed under a Creative Commons Attribution 4.0 International License.  By contributing you agree that your contributions will be licensed under the Creative Commons Attribution 4.0 International License. Feel free to contact the maintainers if that's a concern.</p>"},{"location":"documentation/CONTRIBUTING/#contacting-maintainers","title":"Contacting Maintainers","text":"<p>TrenchBoot is maintained by:  - Daniel P. Smith dpsmith@apertussolutions.com</p>"},{"location":"documentation/CONTRIBUTING/#references","title":"References","text":"<p>This document was adapted from the this open-source contribution template</p>"},{"location":"documentation/DevelopersGuide/","title":"Developers Guide","text":"<p>TrenchBoot is a framework that provides for users the ability to select the kernel and security engine components appropriate for their target environment. This developers guide focuses on the software components of TrenchBoot and the build system used to compose TrenchBoot launchable images.</p>"},{"location":"documentation/DevelopersGuide/#trenchboot-linuxu-root-configuration","title":"TrenchBoot Linux/u-root Configuration","text":"<p>A TrenchBoot launchable image consists of a TrenchBoot Linux kernel with a TrenchBoot u-root initramfs embedded within the image. When building for a target, the boot capabilities and BITs that will be supported will result in different launchable images. The diagram below provides a simple visual depiction of this setup.</p> <p></p> <p>As a result of the build process, one or more kernel images may be generated. By convention these kernels will be labeled as such:</p> <ul> <li>bzImage.uefi: An image built to be launch by a UEFI environment</li> <li>bzImage.skinit: An image built to be launched with AMD's SKINIT instruction</li> <li>bzImage.senter: An image built to be launched with Intel's SENTER instruction</li> <li>bzImage.bios: An image build to be launched by a legacy BIOS boot loader</li> </ul>"},{"location":"documentation/Glossary/","title":"Glossary","text":"<p>Provided are definitions of terms used throughout TrenchBoot's documents and designs to encourage a common vocabulary and understanding.</p>"},{"location":"documentation/Glossary/#dynamic-launch","title":"Dynamic Launch","text":"<p>A system launch that can be done repeatedly with the execution code able to reside at different locations in memory. This is sometimes referred to as a \"Late Launch\".</p>"},{"location":"documentation/Glossary/#explicit-trust","title":"Explicit Trust","text":"<p>When a trustor has explicitly established a degree of trust with a trustee.</p>"},{"location":"documentation/Glossary/#implicit-trust","title":"Implicit Trust","text":"<p>When a trustor has relied upon a trustee to establish a degree of trust with another trustee.</p>"},{"location":"documentation/Glossary/#root-of-trust","title":"Root of Trust","text":"<p>An idempotent mechanism whereby the result is used to assert a fact about the entity it acted upon.</p>"},{"location":"documentation/Glossary/#static-launch","title":"Static Launch","text":"<p>A system launch that is a one time execution with the execution code at a fixed location in memory.</p>"},{"location":"documentation/Glossary/#transitive-trust","title":"Transitive Trust","text":"<p>An operation conducted by a trustor that consists of one or more mechanisms used to assess one or more facts about a trustee before allowing the trustee to be included within the trustor's trust boundary and delegated the authority to act as a trustor.</p>"},{"location":"documentation/Glossary/#trust","title":"Trust","text":"<p>Assured reliance on the properties, ability, strength, or truth of an entity.</p>"},{"location":"documentation/Glossary/#trust-anchor","title":"Trust Anchor","text":"<p>The result of a Root of Trust mechanism that is a fact being relied upon to assert correctness, e.g. trustworthiness.</p>"},{"location":"documentation/Glossary/#trust-boundary","title":"Trust Boundary","text":"<p>A demarcation that identifies a subset of entities as those that a trustor has explicitly or implicitly established as trustworthy.</p>"},{"location":"documentation/Glossary/#trustee","title":"Trustee","text":"<p>An entity that is trusted by another entity.</p>"},{"location":"documentation/Glossary/#trustor","title":"Trustor","text":"<p>An entity that establishes a degree of trust of another entity.</p>"},{"location":"documentation/Late_Launch_Overview/","title":"Introduction to Late Launch","text":"<p>This is an introduction of the \"Late Launch\" process on x86-based systems to establish a Dynamic Root of Trust for Measurement (DRTM). Late Launch is another name for a Dynamic Launch of a system for x86-based platforms. As such it is good to understand the difference between a Static Launch and a Dynamic Launch on x86 platforms.  For x86 the fixed location used for a Static Launch is known as the reset vector which maps to SPI flash storage. A Dynamic Launch is achieved with a light-weight processor bootstrap initiated through a CPU instruction. For Intel the capability that provides this is called TXT and is initiated with the GETSEC[SENTER], summarily SENTER, instruction. For AMD it is considered part of AMD's secure virtualization (AMD-V) and is initiated with the SKINIT instruction.</p> <p>An important function of x86 Late Launch CPU instructions is that they \"measure\" the execution code provided for the launch. This action of \"measure\" is accomplished by taking a cryptographic hash using an algorithm supported by the TCG's Trusted Platform Module (TPM) so that it may store the measurement within one of the TPM's Platform Configuration Registers (PCR). This initial measurement, referred to as the Core Root of Trust Measurement (CRTM), is the trust anchor for the DRTM. </p> <p>While the Intel and AMD implementations of Late Launch both achieve a DRTM, how their implementations arrive at a DRTM are significantly different. As a result each will be addressed separately.</p>"},{"location":"documentation/Late_Launch_Overview/#intel-trusted-execution-technology-txt","title":"Intel Trusted eXecution Technology (TXT)","text":"<p>For TXT, Intel set about a holistic approachi[1] that introduced the Safer Mode Extensions (SMX) instruction set. As a result TXT provides for advanced security capabilities such as measuring System Management Mode (SMM) when an SMI Transfer Monitor (STM) is in place. The TXT process is built around the SINIT Authenticated Code Module (ACM) and a Measured Launch Environment (MLE). The ACM is a binary provided by Intel and the MLE is a software solution typically provided by the OS provider. Details about the ACM and the MLE are explained in the \"Intel TXT Measured Launch Environment Developer's Guide\". [2]</p>"},{"location":"documentation/Late_Launch_Overview/#senter-procedure","title":"SENTER Procedure","text":"<p>From the moment when the SENTER instruction is invoked until execution control is handed to the MLE, a series of computations are completed by the CPU and then by the ACM to generate integrity assertions in the form of measurements about the platform environment as well as the MLE that will be given control. Details about the CPU's role in the launch can be found in the Intel Software Developer's Manual (SDM) under Vol. 2D 6.2.3 para 3 and 6.3 GETSEC[SENTER]. [3] The primary role for the CPU is to establish an environment that minimizes the ability of external tampering and taking the CRTM used for the DRTM. Below is an outline of the internal steps that the CPU takes when the SENTER instruction is initial invoked,</p> <ol> <li>Inhibit processor response to external events: INIT, A20M, NMI, and SMI.</li> <li>Establish and check the location and size of the authenticated code module to be executed by the ILP.</li> <li>Check for the existence of an Intel\u00ae TXT-capable chipset.</li> <li>Verify the current power management configuration is acceptable.</li> <li>Broadcast a message to enable protection of memory and I/O from the activities of other processor agents.</li> <li>Load the designated AC module into the authenticated code execution area.</li> <li>Isolate the content of the authenticated code execution area from further state modification by external agents.</li> <li>Authenticate the AC module.</li> <li>Updated the Trusted Platform Module (TPM) with the authenticated code module's hash.</li> <li>Initialize processor state based on the authenticated code module header information.</li> <li>Unlock the Intel\u00ae TXT-capable chipset private configuration register space and TPM locality 3 space.</li> <li>Begin execution in the authenticated code module at the defined entry point.</li> </ol>"},{"location":"documentation/Late_Launch_Overview/#txt-acm","title":"TXT ACM","text":"<p>The ACM is the portion that is responsible for implementing the advanced security capabilities provided by TXT. To achieve this, the CPU provides a highly privileged execution mode that is capable of inspecting System Management Mode (SMM) memory (SMRAM), this is needed to allow the measurement of the STI. As a result it is highly important that only authorized code is allowed to execute in this mode. This is handled in step 8., the authentication of the ACM. The details of this process can be found in section A.1.2 of the MLE Developers Guide. [2] The ACM is entrusted with a series of responsibilities, ones of particular note are IOMMU protecting the MLE, measuring the MLE, and the enforcement of the Launch Control Policy (LCP), </p>"},{"location":"documentation/Late_Launch_Overview/#launch-control-policy","title":"Launch Control Policy","text":"<p>One of the capabilities provided by the ACM is the LCP Engine. The LCP is a rarely used mechanism to enforce that a known environment is being used. Within the ACM is an LCP engine that will look for a LCP in a designated TPM NVRAM address. The LCP allows for defining expected values for TPM PCRs and/or the expected hash value of the MLE. If a policy check fails, then the LCP Policy Engine will trigger the ACM to error exit from the SENTER instruction.</p>"},{"location":"documentation/Late_Launch_Overview/#measured-launch-environment","title":"Measured Launch Environment","text":"<p>The final component in the Intel TXT process is the MLE, a software component that is responsible for the secure setup and execution of the target runtime. As the ACM conducted a transitive trust extension to the MLE, the MLE should similar conduct a transitive trust extension to bring the target runtime within the SMX trust boundary by protecting the runtime's memory from tampering, measuring the runtime, and optionally enforcing policy to ensure only authorized runtimes are allowed to execute.</p>"},{"location":"documentation/Late_Launch_Overview/#amd-secure-startup","title":"AMD Secure Startup","text":"<p>The AMD approach is a simpler one that allows more control over code executed by the SKINIT instruction, to include environment setup and measurements, but unlike Intel's ACM, execution is limited to the same accesses as superprivileged mode. This means it is not possible to obtain a measurement of SMRAM at the time of the late launch. Therefore the trust boundary of SKINIT still bound to the SRTM. To use the Secure Startup capability, a Secure Loader (SL) image must be loaded and passed to SKINIT. Details about building an SL and calling the SKINIT instruction can be found in the AMD ARM64 Architecture Programmer's Manual, Volume 2. [2]</p>"},{"location":"documentation/Late_Launch_Overview/#skinit-procedure","title":"SKINIT Procedure","text":"<p>When the SKINIT instruction is executed, the base address for the SL is passed in the EAX register. The CPU will then execute the following sequence,</p> <ol> <li>Reinitialize the processor state similar to INIT signal</li> <li>Enter 32bit protected mode with paging disabled</li> <li>Clear all general purpose registers except,<ul> <li>EAX: start address of SL</li> <li>EDX: CPU model, family, and stepping</li> </ul> </li> <li>Secures registers,<ul> <li>Most MSRs retain their values (except those which might compromise SVM protections)</li> <li>EFER MSR is cleared</li> <li>setting DPD, R_INIT and DIS_A20M flags in the VM_CR register unconditionally to 1</li> </ul> </li> <li>Page align EAX and use as the start address for 64KBytes of DEV protection</li> <li>Securely initializes AP(s)<ul> <li>clears Global Interrupt Flag (GIF)</li> <li>setting DPD, R_INIT and DIS_A20M flags in the VM_CR register</li> </ul> </li> <li>Transmit SL image to TPM for hash, any failure will trigger SKINIT failure</li> <li>Clear the GIF on the BSP which disables all interrupts, including NMI, SMI, and INIT</li> <li>Update ESP to point at SL stack (SLB base + 65536)</li> <li>Add SL entry offset to SL base and jump to that address</li> </ol>"},{"location":"documentation/Late_Launch_Overview/#secure-loader","title":"Secure Loader","text":"<p>In the AMD world, the initial code executed by the SKINIT instruction is the Secure Loader (SL). The SL is an Owner provided code base that is responsible for securely initializing the system and handover to a Security Kernel (SK). The SL must meet two primary conditions,</p> <ol> <li>SL image's first two words contain the entry point offset and image size</li> <li>SL image and stack must be less than 64KBytes</li> <li>SL image must be loaded page aligned</li> </ol> <p>Upon execution, the SL is responsible for protecting the remainder of the execution environment through measurement and memory protection of the SK to which it will be handing over control.</p>"},{"location":"documentation/Late_Launch_Overview/#security-kernel","title":"Security Kernel","text":"<p>For AMD Secure Startup the last component is the SK. The SK can be an intermediate kernel or a target runtime kernel. The situation that drives the need for an intermediate kernel is for solutions that need to do more complex security verification and/or hand-off to target runtime kernel that cannot be implemented in less than 64Kbytes.</p>"},{"location":"documentation/Late_Launch_Overview/#foot-notes","title":"Foot Notes","text":""},{"location":"documentation/Late_Launch_Overview/#1","title":"1.","text":"<p>Grawrock, D. (2006). The Intel safer computing initiative. Hillsboro, Or.: Intel Press. https://books.google.com/books?id=WmGjSgAACAAJ</p>"},{"location":"documentation/Late_Launch_Overview/#2","title":"2.","text":"<p>Intel\u00ae Trusted Execution Technology (Intel\u00ae TXT) Software Development Guide: Measured Launched Environment Developer\u2019s Guide</p> <p>https://www.intel.com/content/dam/www/public/us/en/documents/guides/intel-txt-software-development-guide.pdf</p>"},{"location":"documentation/Late_Launch_Overview/#3","title":"3.","text":"<p>Intel\u00ae 64 and IA-32 Architectures Software Developer\u2019s Manual, Combined Volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D and 4</p> <p>https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf</p>"},{"location":"documentation/Late_Launch_Overview/#4","title":"4.","text":"<p>AMD64 Architecture Programmer\u2019s Manual Volume 2: System Programming</p> <p>https://www.amd.com/system/files/TechDocs/24593.pdf</p>"},{"location":"documentation/UseCases/","title":"TrenchBoot Use Cases","text":"<p>TrenchBoot is meant to be a universal framework to enable building integrity in the launch process of systems. To relate to real world usage, it is good to have a set of use cases that explain a subset of situations where TrenchBoot is applicable and how it would work in those situations. Below are a series of use cases that are actively being investigated and/or worked on.</p>"},{"location":"documentation/UseCases/#crowd-sourcing-integrity","title":"Crowd Sourcing Integrity","text":"<p>There is currently no known public authority available to verify BIOS/Firmware PCR values. TrenchBoot would like to become such an authority but there is the challenge of how to obtain all these values in a manner that provide assurance to the authenticity of the values. Crowd sourcing provides the best means to collect the largest and most diverse set of values. The challenge with crowd sourcing the values is how to establish authenticity of the values. This challenge can be overcome with a TrenchBoot based live CD that establishes an attestation identity provisioned by a TrenchBoot Attestation Certificate Authority (ACA).</p>"},{"location":"documentation/UseCases/#network-attestation-launch","title":"Network Attestation Launch","text":"<p>An individual or enterprise may not want to allow a system to boot on their network unless it is running a known configuration. When TrenchBoot is installed onto a system it will work in conjunction with a TrenchBoot ACA (public or private instance) that provides a key management service. TrenchBoot will hold a portion of a Shamir Secret Sharing key with another portion held by the key management service. For the system to boot it will attest to the key management service to obtain a key fragment that will allow it to unlock the system disk.</p>"},{"location":"documentation/UseCases/#travel-laptop-2fa-launch","title":"Travel Laptop 2FA Launch","text":"<p>When travelling there are times when an individual loses positive control of their device. During these times attackers can launch physical access attacks. For this configuration TrenchBoot will \"double chain wrap\" the encryption key for decrypting the system where each chain wrap correlates to an authentication factor. Working internal to external, the system drive key is encrypted with the first wrap key that is in turned encrypted with the second wrap key. The first wrap key is stored on a removable token device, e.g. YubiKey, and the second wrap key is sealed in a TPM NVRAM slot. For a system to boot it must have launched with the correct firmware and the token must be present.</p>"},{"location":"documentation/gitlab_CI/","title":"GitlabCI configuration documentation","text":""},{"location":"documentation/gitlab_CI/#preparation","title":"Preparation","text":""},{"location":"documentation/gitlab_CI/#github","title":"GitHub","text":"<ul> <li>Create account for CI bot</li> <li>grant <code>Admin</code> access to this bot in the repositories you will want to use     GitLabCI with</li> </ul>"},{"location":"documentation/gitlab_CI/#gitlab","title":"GitLab","text":"<ul> <li>Create account for CI bot</li> </ul>"},{"location":"documentation/gitlab_CI/#configuration","title":"Configuration","text":""},{"location":"documentation/gitlab_CI/#gitlabci-for-github-integration","title":"GitLabCI for GitHub integration","text":"<p>The process is descriebd in the official documentation.</p> <p>Following projects were integrated:</p> <ul> <li><code>TrenchBoot</code> GitHub repositories:</li> <li>grub</li> <li>landing-zone</li> <li> <p>linux</p> </li> <li> <p><code>3mdeb</code> GitHub repositories:</p> </li> <li>grub</li> <li>landing-zone</li> <li>linux</li> <li>meta-trenchboot</li> <li>nixos-trenchboot-configs</li> </ul>"},{"location":"documentation/gitlab_CI/#cicd-variables","title":"CI/CD variables","text":"<p>Following variables are used on the trenchboot1 group level (they are used by both the repositories in <code>TrenchBoot</code> and <code>3mdeb</code> subgroups): - <code>CACHIX_AUTHTOKEN</code> - authotken to push nix artifacts to the   3mdeb cachix - <code>CACHIX_SIGNING_KEY</code> - signing key to sign the artifacts pushed to the   3mdeb cachix - <code>RTE_IP_1000V</code> - local IP of the RTE   connected to the <code>Asrock R1000V</code> board - <code>RTE_IP_APU2</code> - local IP of the RTE   connected to the <code>APU2</code> board - <code>RTE_IP_SUPERMICRO</code> - local IP of the RTE   connected to the <code>Supermicro m11sdv-8ct-ln4f</code> board - <code>YOCTO_CACHE_PATH</code> - local path where the Yocto cache is stored in the local   <code>HTTP</code> server - <code>YOCTO_HTTP_CACHE_IP</code> - local IP address of the HTTP cache server - <code>YOCTO_HTTP_CACHE_RSYNC_KEY</code>- private SSH key used to populate the Yocto   downloads/sstate cache on the local server using <code>rsync</code> - <code>YOCTO_HTTP_CACHE_USER</code> - username to the local HTTP cache server</p> <p>Following variables are used on the trenchboot1/3mdeb subgroup level: - <code>GITHUB_GROUP</code> - gitlab group prefix for <code>3mdeb</code> repositories - <code>GITHUB_GROUP</code> - github group prefix for <code>3mdeb</code> repositories</p> <p>Following variables are used on the trenchboot1/trenchboot subgroup level: - <code>GITHUB_GROUP</code> - gitlab group prefix for <code>TrenchBoot</code> repositories - <code>GITHUB_GROUP</code> - github group prefix for <code>TrenchBoot</code> repositories</p> <p>Thanks to the group variables, we can have the same <code>.gitlab-ci.yml</code> content for both groups, and adjust some variables (like prefixes) there.</p>"},{"location":"documentation/gitlab_CI/#setting-up-local-runners","title":"Setting up local runners","text":"<p>Follow the gitlab-runner documentation.</p>"},{"location":"documentation/gitlab_runner/","title":"Running","text":"<p>Use <code>docker-compose</code> script from the trenchboot-ci repository:</p> <pre><code>docker-compose up\n</code></pre> <p>On first run you will see there is no config file:</p> <pre><code>gitlab-runner1_1  | ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0\ngitlab-runner1_1  | ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0\n</code></pre> <p>You need to perform the registration.</p>"},{"location":"documentation/gitlab_runner/#registration","title":"Registration","text":"<ol> <li> <p>Go to CI/CD settings    in your group.</p> </li> <li> <p>Go to the <code>Set up a group Runner manually</code> section and set the    <code>registration token</code> as environmental variable:</p> </li> </ol> <p><code>bash    export REGISTRATION_TOKEN=\"QZgfyepK2_t3SshRgX2K\"</code></p> <ol> <li>Register using the script:</li> </ol> <p>```bash    ./gitlab-runner-register.sh</p> <p>Runtime platform                                    arch=amd64 os=linux pid=142 revision=ce065b93 version=12.10.1    Running in system-mode.</p> <p>Registering runner... succeeded                     runner=QZgfyepK    Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded!    ```</p> <ol> <li>The containter logs should become:</li> </ol> <p><code>gitlab-runner1_1  | Configuration loaded                                builds=0</code></p> <ol> <li>The runner should be available in the    CI/CD group settings</li> </ol> <p></p> <ol> <li>Refer to the    register documentation    if needed.</li> </ol>"},{"location":"documentation/gitlab_runner/#usage","title":"Usage","text":"<p>Local runner can run the exact same jobs as a shared runnners in the cloud. Typically, we will want to mark some specific jobs to run on the local runner instead. Examples of such jobs: - local infastructure acces required, - extensive hardware requirementes (shared runners have limited resources).</p> <p>In the gitlab-runner-register.sh we are providing a list of tags as one of the arguments:</p> <pre><code>--tag-list local \\\n</code></pre> <p>In this case, we mark our runner with a <code>local</code> tag. We can mark a specific job (in a <code>.gitlab-ci.yml</code> file) with the same tag, to make sure it will always run on a local runner, rather the shared (cloud one). The syntax is:</p> <pre><code>  tags:\n    - local\n</code></pre> <p>Please refer to the tags description in the official documentation.</p>"},{"location":"documentation/test_matrix/","title":"Hardware test matrix","text":"<p>Devices and configurations TrenchBoot has been tested on.</p> Tested devices TPM family Result Notes Intel Tiger Lake client TPM 2.0 PASS UEFI firmware Intel Kaby Lake server TPM 2.0 PASS UEFI firmware Intel Skylake sever TPM 2.0 PASS UEFI firmware PC Engines APU2 platform series (AMD family 16h models 30h-3fh embedded) TPM 2.0 PASS coreboot firmware PC Engines APU2 platform series (AMD family 16h models 30h-3fh embedded) TPM 1.2 PASS coreboot firmware Asus KGPE-D16 (AMD Opteron family 15h models 00h-0fh server) TPM 2.0 FAIL coreboot firmware TPM issue Supermicro M11SDV-8CT (AMD EPYC 3000 Snowy Owl server) TPM 2.0 PASS CSM legacy boot Supermicro M11SDV-8CT (AMD EPYC 3000 Snowy Owl server) TPM 2.0 FAIL UEFI boot"},{"location":"references/","title":"References","text":"<p>Here you will find reference knowledge explaining concepts and theory behind TrenchBoot.</p>"},{"location":"steering-committee/","title":"Steering Commitee Meetings","text":"<p>Here you will find the meeting minutes from the Steering Committiee and Community Meetings.</p> <p>{nav}</p>"},{"location":"steering-committee/Community-Meeting-June17-2021/","title":"Community Meeting June17 2021","text":""},{"location":"steering-committee/Community-Meeting-June17-2021/#agendanotes","title":"Agenda/Notes","text":"<ul> <li> <p>Outreach and Engagement</p> <ul> <li> <p>TrenchBoot Developers Forum</p> <ul> <li> <p>Determine time period and/or dates</p> <ul> <li>Piotr feels every 12 mo would be quite long<ul> <li>is six months too short to discuss things</li> <li>thinks sept. we should have something</li> <li>OSFC planned for Dec.</li> </ul> </li> <li>Rich, should do it when things get cold and are locked up<ul> <li>Do TB talks at multiple events</li> <li>We should have an internal event, but maybe make it a DRTM event</li> </ul> </li> <li>DK, LPC at end of 24Sept<ul> <li>Should have confirmation by the end of June for LPC MC</li> <li>should have slots available for TB talks</li> </ul> </li> </ul> </li> <li> <p>Select chairman to oversee planning/coordination</p> <ul> <li>Piotr we would like to help but cannot do it alone<ul> <li>will engage IBM POWER about sponsoring</li> </ul> </li> <li>Rich recommends bring the topic up at DRTM related meetings and try to find a corporate sponsor</li> </ul> </li> </ul> </li> <li> <p>TrenchBoot website</p> <ul> <li> <p>Identify content that would like to be on the site</p> <ul> <li>Piotr: coreboot is hooking to rss feeds that feed into blog<ul> <li>will look at what coreboot implementation</li> <li>will look at mkdocs setup to move TB documentation over to</li> </ul> </li> <li>DanK: will speak with a colleague, will have a response when back from vacation</li> </ul> </li> <li> <p>Discuss approach to maintenance/development</p> <ul> <li>should apply GH auto fixes</li> </ul> </li> </ul> </li> <li> <p>TrenchBoot Social Media</p> <ul> <li>Review social media accounts and strategy<ul> <li>Twitter</li> <li>LinkedIn project site/group</li> <li>Others?</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Project</p> <ul> <li> <p>Moving AMD support forward</p> <ul> <li> <p>LZ renaming</p> <ul> <li>Piotr thinks AMD should be involved in TB AMD related topics<ul> <li>we should also try to get them involved with the call</li> </ul> </li> <li>Rich, this is a public meeting, may need to have NDA meeting</li> </ul> </li> <li> <p>LZ IOMMU approach adoption</p> <ul> <li>Ross: just adopt current proposed approach as a starting place<ul> <li>yes the pitsaw card could be used</li> </ul> </li> <li>Piotr, the current approach is better than nothing<ul> <li>are there tests?</li> </ul> </li> <li>Kanth: can the pitsaw card be used to test iommu for txt, can be used for AMD</li> </ul> </li> <li> <p>DRTM log approach adoption</p> <ul> <li>Piotr: based on TCG spec<ul> <li>this is where the HCL will be useful</li> <li>can test Ross changes for linux kernel</li> <li>will work on \"legacy mode\" support</li> </ul> </li> <li>Ross: need to handle system without the ACPI table<ul> <li>can make so that the ACPI table is preferred approach then fail back to non-ACPI table</li> <li>for the LZ will need to also be made to handle non-ACPI table situation (legacy mode)</li> <li>will work on \"legacy mode\" support</li> </ul> </li> <li>Daniel: merge the PR<ul> <li>has been confirmed on pc-engines</li> </ul> </li> </ul> </li> <li> <p>iPXE support</p> <ul> <li>Piotr: submitted patches but rejected as too big<ul> <li>https://github.com/ipxe/ipxe/pull/300</li> <li>we should care about iPXE</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Upcoming v2 LKML submission</p> <ul> <li>Ross: it looks like it will be going out tomorrow (6/18/2021)</li> </ul> </li> <li> <p>GRUB submission</p> <ul> <li>Daniel K: currently working with Lukasz and will looking to submit in July<ul> <li>will be working with 3mdeb on aligning AMD changes</li> </ul> </li> </ul> </li> <li> <p>Deployment/Adoption support</p> <ul> <li> <p>TrenchBoot Hardware Compatibility List</p> <ul> <li>How to check if my hardware is supported or can be supported?<ul> <li>Piotr: resource constrained but we need something very basic<ul> <li>what all should be checked, log, pcrs, etc</li> <li>this is QubesOS HCL as an example<ul> <li>https://www.qubes-os.org/hcl/</li> </ul> </li> <li>list of hardware for people to get started with</li> </ul> </li> <li>Rich:<ul> <li>there are a lot of things that make you feel better but not gain much<ul> <li>maybe skip over that and focus on community</li> </ul> </li> <li>biggest issues will be with hardware that is not MS certified</li> <li>both OXT and Qubes HCL are not correct because every system has quirks</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>TrenchBoot Canonical Demo</p> </li> <li> <p>TrenchBoot as AEM for QubesOS</p> <ul> <li>Piotr: would be good to assist with anit-evil maid demo</li> </ul> </li> </ul> </li> <li> <p>Test automation (Kanth)</p> <ul> <li>Rich suggest this is a place for Qemu support for DRTM to enable software based testing<ul> <li>at tdf txt lead mentioned txt test suite in FWUPD</li> <li>we should get OEM testing</li> <li>could TB lead DRTM test suite development</li> <li>if there isn't one, who is willing to fund its development</li> <li>live cd is not enough, need to build a cross-community project</li> <li>this can be a theme for the DRTM event</li> </ul> </li> <li>Piotr agrees that this FWUPD testing support is desired</li> <li>Kanth, Oracle will be increasing supported platforms and would like to see automated testing/validation<ul> <li>Oracle would be interested in helping with building a DRTM test framework</li> </ul> </li> <li>Daniel K: GRUB does not have automated testing but it is in progress<ul> <li>thinks it would be quite easy to introduce tests for preamble </li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Additional Topics (time permitting)</p> </li> <li> <p>DRTM/TrenchBoot for Arm         - Stuart: Beta spec will be public by fall and possible reference implementation         - Rich: coordinate a TB event around Arm event/announcement </p> </li> <li> <p>Plan for SMM         - intel whitepaper on SMM DRTM protection</p> </li> <li> <p>Integration with FWUPD hardware security test</p> </li> <li> <p>General Business</p> <ul> <li> <p>Open floor for community members</p> </li> <li> <p>Next meeting</p> <ul> <li>Piotr we missed several topics<ul> <li>discuss getting more resources</li> <li>fobnail</li> <li>testing</li> </ul> </li> <li>Rich we should not do meetings during the summer and do out-of-band discussions (chat/email)<ul> <li>perhaps use OSFC TB slack</li> </ul> </li> <li>Will be done virtually via TB slack channel</li> </ul> </li> </ul> </li> </ul>"}]}